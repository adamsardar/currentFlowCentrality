# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title generate the Moore-Penrose psueoinverse using the armadillo package
#' @description The Armadillo package provides a low level interface to native LAPACK/BLAS routines
#' and we plan to use the divide-and-conquer implementation of SVD to generate the psuedo-inverse
#' @param X A matrix to be psuedo-inverted
#' @return An armadillo (dense) matrix containg the psuedo-inverse values 
#' @references \url{http://en.wikipedia.org/wiki/Moore-Penrose_pseudoinverse}
#' @references \url{http://gallery.rcpp.org/articles/divide-and-concquer-svd/}
dcPinvDense <- function(X) {
    .Call('_currentFlowCentrality_dcPinvDense', PACKAGE = 'currentFlowCentrality', X)
}

#' @title generate the Moore-Penrose psueoinverse using the armadillo package
#' @description The Armadillo package provides a low level interface to native LAPACK/BLAS routines
#' It provides several implementations of SVD and this function uses the standard algorithm
#' @param X A matrix to be psuedo-inverted
#' @return An armadillo (dense) matrix containg the psuedo-inverse values 
#' @references \url{http://en.wikipedia.org/wiki/Moore-Penrose_pseudoinverse}
#' @references \url{http://gallery.rcpp.org/articles/divide-and-concquer-svd/}
standardPinv <- function(X) {
    .Call('_currentFlowCentrality_standardPinv', PACKAGE = 'currentFlowCentrality', X)
}

#' @title generate the average resistive distance per node
#' @description We take advantage of the notion of resistor network to define current-flow distance.
#' Given nodes \eqn{i} and \eqn{j}, the resistance distance \eqn{R_{i,j}}{R_ij} between \eqn{i} and \eqn{j}
#' is the effective (or equivalent) resistance between \eqn{i} and \eqn{j} when a unit of current is injected
#' from source \eqn{s} and removed from target \eqn{t}.
#' @param graphLaplacianInv The psuedoinverse of the graph laplacian. The graph MUST be fully connected - I make no checks for you ...
#' @return currentFlowDistances A column matrix of resistive distances from the network
#' @references \url{http://www.sci.unich.it/~francesc/teaching/network/flowcentrality.html}
#' @export
calculateCurrentFlowDistance <- function(graphLaplacianInv) {
    .Call('_currentFlowCentrality_calculateCurrentFlowDistance', PACKAGE = 'currentFlowCentrality', graphLaplacianInv)
}

#' @title for a single source and single sink node of unit current, calculate the per-node flow
#' @description We take advantage of the notion of resistor network to define current-flow. It is defined as
#' \deqn{F_{i}^{(st)}=\frac{1}{2} \sum_{j} A_{ij} \left | V_{i}^{(st)} - V_{j}^{(st)}  \right |}
#' Given nodes \eqn{i} and \eqn{j} and a unit of current injected from source \eqn{s} and removed from target \eqn{t}.
#' @param Gpinv The psuedoinverse of the (undirected) graph laplacian. The graph MUST be fully connected - I make no checks for you ...
#' @param adjacency The adjacency matrix of a (undirected) graph
#' @param sourceIndex The integer index of the source of unit flow
#' @param sinkIndex The integer index of the sink of unit flow
#' @return currentFlowDistances A column matrix of resistive distances from the network
#' @references \url{http://www.sci.unich.it/~francesc/teaching/network/flowcentrality.html}
singleSourceTargetFlow <- function(Gpinv, adjacency, sourceIndex, sinkIndex) {
    .Call('_currentFlowCentrality_singleSourceTargetFlow', PACKAGE = 'currentFlowCentrality', Gpinv, adjacency, sourceIndex, sinkIndex)
}

#' @title calculate the average current flow betweeness
#' @description We take advantage of the notion of resistor network to define current-flow. It is defined as
#' \deqn{F_{i}^{(st)}=\frac{1}{2} \sum_{j} A_{ij} \left | V_{i}^{(st)} - V_{j}^{(st)}  \right |}
#' Given nodes \eqn{i} and \eqn{j} and a unit of current injected from source \eqn{s} and removed from target \eqn{t}.
#' The current flow betweeness is defined as: \deqn{b_{i} = \frac{\sum_{s<t} F_{i}^{(st)} }{\frac{1}{2}n(n-1))}}. Hence
#' averageing over all \eqn{s} - \eqn{t} pairs.
#' @inheritParams singleSourceTargetFlow
#' @export
#' @param graphLaplacianInv The psuedoinverse of the graph laplacian. The graph MUST be fully connected - I make no checks for you ...
#' @return currentFlowBetweeness A vector of current flow betweeness, averaged over all source-sink pairs
#' @references \url{http://www.sci.unich.it/~francesc/teaching/network/flowcentrality.html}
calculateAverageCurrentFlowBetweeness <- function(graphLaplacianInv, adjacency) {
    .Call('_currentFlowCentrality_calculateAverageCurrentFlowBetweeness', PACKAGE = 'currentFlowCentrality', graphLaplacianInv, adjacency)
}

#' @title generate the pairwise resistive distance
#' @description We take advantage of the notion of resistor network to define current-flow distance.
#' Given nodes \eqn{i} and \eqn{j}, the resistance distance \eqn{R_{i,j}}{R_ij} between \eqn{i} and \eqn{j}
#' is the effective (or equivalent) resistance between \eqn{i} and \eqn{j} when a unit of current is injected
#' from source \eqn{s} and removed from target \eqn{t}.
#' @inheritParams calculateCurrentFlowDistance
#' @return currentFlowDistances A matrix of pairwise resistive distances from the network
#' @references \url{http://www.sci.unich.it/~francesc/teaching/network/flowcentrality.html}
#' @export
calculateResistiveDistances <- function(graphLaplacianInv) {
    .Call('_currentFlowCentrality_calculateResistiveDistances', PACKAGE = 'currentFlowCentrality', graphLaplacianInv)
}

